# js对象

## 1、js的解析与执行过程

### 1、全局

#### 1、预处理阶段

##### 1、创建词法环境 Lexical Environment

全局的词法环境对象等价于window对象（顶级的Lexical Environment是window）

ecma 标准文档里面，词法环境对象分的比较详细，有变量的environment等。

```
lexicalEnvironment{
    a: undefined
    xxx: 对函数的一个引用
}
```

用var定义的变量

用声明的方式创建的函数

```
函数表达式的方式
var g = function() {}
函数声明的方式
function xxx() {}
```

##### 2.先扫描函数声明后扫描变量（var声明）

处理函数声明时有冲突，会覆盖

处理变量声明时有冲突，会忽略



#### 2、执行阶段



### 2、函数

#### 1、预处理阶段

每调用依次，产生一个lexical environment

先函数的参数。内部声明式函数，内部var变量，冲突情况与全局处理一样

```
首先把函数的参数写入，然后内部声明式函数写入词法，冲突情况：函数和参数的冲突以函数为主，参数和var变量冲突以参数为主
```



#### 2、执行阶段

给预处理阶段的成员赋值

如果没有用var声明的变量，会成为最外部的词法环境成员



## 2、作用域

```
示例代码：
console.log(a);
console.log(b);
console.log(c);
console.log(d);

var a = 1;
if (false) {
var b = 2;
} else {
c = 3;
}
function f() {
var d = 4;
}
```



### 1、定义

确定一个变量，函数，成员在整个程序里面可以被访问

### 2、块作用域

js没有块作用域的概念

```
{}
在这个块里面生效，外面不生效
```



### 3、函数作用域

在函数内部生效，外部不生效



### 4、动态作用域

js本身没有动态作用域的概念，本身是静态作用域

```
function f() {
console.log(x);
}
function f1() {
var x = 5;
f();
}
function f2() {
var x = 6;
f();
}
```



### 5、词法作用域（也称为静态作用域或闭包）

什么是静态，就是在声明的阶段就已经确定了相关的作用域

```
对于一个函数要使用一个变量/函数，首先会从它本身的一个词法环境里面去寻找，如果找不到就去它的scope，就是创建它的那个词法环境去寻找，直到到window对象
```



#### 1.js的作用域解析

```
function f() {}
function f1() {f()}
```

在创建f函数的时候，会添加一个成员，一个看不到摸不着的成员[[scope]]，这个值，就等于创建它的那个词法环境，所以等于window，

当真正执行f()的时候，会创建自己的词法环境，会和f.[[scope]]进行关联，如果在自己的词法环境里面找不到变量，就会去scope里面进行寻找，如果找不到就会报错

```
le:词法环境
function f() {	//scope == window
	// le{x=100} -> f.[[scope]]
	var x = 100;
	function g() {	//g.[[scope]] == f.le
		le -> g.[[scope]]
	}
	g();
}
g.le -> g.[[scope]](f.le) -> f.[[scope]](window)
```



#### 2.用new function创建函数

```
function f() {}
var f = function () {}
var f = function x(argument) {}
var f = new Function('', 'alert(xxx')
```

```
function f() {
var x = 100;
g.[[scope]] == window ,而不是等于f.le
var g = new Function('', 'alert(x)');
g();
}
```



#### 3.闭包初识

在这里，我们可以将a，b放在了匿名函数里面，然后把f赋值给了window对象里面，通过这样，可以把a，b不用写成全局作用域，

但是对于c系列的语言来说，局部变量在执行之后会弹出（因为局部变量是放在栈里面）所以在这个匿名执行函数执行之后，应该会把ab的变量弹出，但是js不会这样

```
(function() {
var a = 5;
var b = 6;
function f() {
console.log(a);
}
window.f = f;
})();
f();
```



## 3.闭包

### 1.什么是闭包

学习Javascript闭包（Closure） ．新浪博客

```
闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取[局部变量]，所以闭包可以理解成“定义在一个[函数]内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁
```

Wiki的解释

```
在计算机科学中，闭包（closure）是词法闭包（lexical closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。
```

```
在程序预处理阶段，先生成了f1的词法环境，在进行函数的预处理时，会查看是否需要父类函数的变量，如果需要就会提前把值写入scope中，（不同浏览器的做法不同，有的可能会直接把f1的le词法环境直接写入scope中）然后逐步进行执行，到了f1的子函数内部f2。


（1.会将f1的词法环境全部保存入f2的闭包中）（2.会在f2预处理和执行（函数在需要被执行的时候才会进行预处理）所以发现子函数f2会使用父函数f1的变量，此时再把变量放入f2的scope的闭包中（这里理解应该是错误的）
```

```
代码示例：
function f1() {
//这里先进行f1的预处理，里面有a,f2（在f1预处理时对f2进行预处理，发现需要f1的变量再把变量写入f2.scope里面）,b,c
//然后逐步执行到f2
	var a = 100;
    function f2() {
        var d = 10;
        console.log(a);
    }
    var b = 200;
    f2();
    var c = 300;
}
f1();
```



```
1.一种认为闭包是一个对象，对象里面是一个函数和被函数封闭捕获的变量
2.另一种，闭包是一种函数，函数里面带着被函数封闭捕获的变量
```

```
2.在js里面，一个函数要在另一个函数的内部才会产生闭包。
```

```
3.一个函数没有使用到父函数的的东西，不会产生闭包
```

```
4.函数使用了父的父也产生闭包
```

```
5.不一定要把子函数返回出去，只要子函数使用了父函数的变量就产生了闭包
function f1() {
function f2() {

}
f2()
}
```

```
6.闭包是什么时候创建的，是在函数被创建，但是没有执行的时候，在那个预处理阶段，发现需要使用到父类的变量，所以使用到了闭包。
```

```
7.闭包的本质，js支持作用域链，并且支持函数嵌套函数
```



### 2.‘闭’了什么



### 3.如何查看闭包



### 4.闭包的好处

减少全局变量

减少传递给函数的参数数量

```
function calFactory(base) {
return function (max) {
var total = 0;
for (let i=1; i<-max; i++) {
total += i;
}
return total + base;
}
}
var adder = calFactory(2);
alert(adder(3));
```

封装

```
(function (){
var m = 0;
function getM() {
return m;
}
function setM(val) {
m = val;
}
window.g = getM;
window.s = setM;
})();
s(12);
console.log(g());
```



### 5.使用闭包的注意点

1.对捕获的变量只是一个引用，不是复制

2.父函数每调用依次，会产生不同的闭包

3.循环中的问题



