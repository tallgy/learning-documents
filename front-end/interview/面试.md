# 面试

## 回流/重绘

```
https://blog.csdn.net/weixin_34353714/article/details/91445129
```

### 浏览器的渲染过程

```
https://blog.csdn.net/farsight1/article/details/79758347
处理 HTML 并tokeniser标记构造 DOM 树。
处理 CSS 标记并构造 CSSOM 树。
如果遇到了js会停止dom树的解析，并且如果js还操作了cssom，并且cssom没有下载和构建，浏览器甚至会延迟脚本执行和构建dom，直至cssom的下载完成和构建
然后 将dom和cssom合并位渲染树 render tree
根据渲染树来布局，计算每个节点的几何信息
将节点绘制到屏幕上
```

### 渲染树 的生成

```
遍历可见的节点
对于可见的节点，找到cssom的规则，并 渲染

注意：
一些不会渲染输出的节点。比如 script、meta、link等。是不可见的
某些节点通过 CSS 隐藏。注意 visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。
```

### 回流(reflow)

当 Render Tree 中**部分或全部, 因元素的尺寸、布局、隐藏等改变而需要重新构建，浏览器重新渲染的过程**称为回流。

```
会导致回流的操作：
  页面首次渲染。
  浏览器窗口大小发生改变。
  元素尺寸或者位置发生改变。
  元素内容变化(文字数量或者图片大小发生改变)。
  元素字体大小的改变。
  添加或者删除可见的 DOM 元素。
  激活 CSS 伪类 (eg: :hover)。
  查询某些属性或调用某些方法。

一些常用且会导致回流的属性和方法。
  clientWidth、clientHeight、clientTop、clientLeft
  offsetWidth、offsetHeight、offsetTop、offsetLeft
  scrollWidth、scrollHeight、scrollTop、scrollLeft
  scrollIntoView()、scrollIntoViewIfNeeded()
  getComputedStyle()
  getBoundingClientRect()
  scrollTo()
```

### 重绘(repaint)

当页面中元素样式的改变并不影响布局时（eg：`color`、`background-color`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**一句话： 回流必将引起重绘，重绘不一定会引起回流。**

### 现代浏览器对频繁的回流/重绘的优化

浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

```
当你访问以下属性或方法时，浏览器会立刻清空队列：
  clientWidth、clientHeight、clientTop、clientLeft
  offsetWidth、offsetHeight、offsetTop、offsetLeft
  scrollWidth、scrollHeight、scrollTop、scrollLeft
  scrollIntoView()、scrollIntoViewIfNeeded()
  getComputedStyle()
  getBoundingClientRect()
  scrollTo()
 
		因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。
```

### 优化回流

```
减少 render tree 操作，合并多次多dom和样式的的修改
减少对一些style信息的请求，尽量利用好浏览器的优化策略
```

#### css

直接改变className

避免使用table布局(尽量不要使用表格布局，如果没有定宽表格一列的宽度由最宽的一列决定，那么很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。)

尽可能在dom树的最末端改变class，尽可能在dom树的里面改变class（可以显示回流的范围）

将需要多次重排的元素，position属性设置位absolute或fixed，这样此元素就脱离了文档流，她的变化不会影响到其他元素。例如有动画效果的元素就最好 设置为绝对定位。

使用 display:none技术，只引发两次回流和重绘。

#### js

避免频繁操作，最好一次性重写style属性，或者将样式列表定义为class，并一次性更改class属性，而不是利用js控制样式

不要经常访问会引起浏览器缓存队列的属性（上述那些浏览器会立刻清空队列的属性）。如果确实要访问，利用缓存 eg：

```
// bad
for (var i = 0; i < len; i++) {
  el.style.left = el.offsetLeft + x + "px";
  el.style.top = el.offsetTop + y + "px";
}

// good
var x = el.offsetLeft,
    y = el.offsetTop;
for (var i = 0; i < len; i++) {
  x += 10;
  y += 10;
  el.style = x + "px";
  el.style = y + "px";
}
```

尽量将需要改变dom的操作一次完成

```
let box = document.getElementById("box").style;
// bad
box.color = "red";    // 重绘
box.size = "14px";    // 回流、重绘

// good
box.bord = '1px solid red'
```

对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

避免频繁操作 `DOM`，创建一个`documentFragment`，在它上面应用所有 `DOM` 操作，最后再把它添加到文档中。

```
DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象. 与 Document 最大的区别是因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的（重新渲染) ，且不会导致性能等问题。

可以使用 document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.
```

## requestAnimationFrame 为什么不会掉帧

```
	首先，我们可以知道布局绘制和js执行都是在主线程进行的执行的，
	所以，如果当js拿到主线程执行权后，有可能会出现执行时间过长，导致在下一帧的开始js没有及时归还主线程，导致下一帧没有按时渲染，于是就会出现掉帧，而这个requestAnimationFrame方法就是解决这个问题的，
	他会在每一帧被调用，通过回调函数，会把js任务分成更小的任务快，并且会在每一帧时间用完暂停js的执行，归还主线程，所以布局绘制就会在每帧及时拿到主线程的使用权，所以不会掉帧。
```

```
requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。
「requestAnimationFrame的步伐跟着系统的刷新步伐走」，
「它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次」，
「这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题」。
```

```
requestAnimationFrame还有以下两个优势：

「CPU节能」：
		使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。

「函数节流」：
		在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。
```

下面为《HTML5 Canvas 核心技术》给出的兼容主流浏览器的requestNextAnimationFrame 和cancelNextRequestAnimationFrame方法

```
window.requestNextAnimationFrame = (function () {
    var originalRequestAnimationFrame = undefined,
        wrapper = undefined,
        callback = undefined,
        geckoVersion = null,
        userAgent = navigator.userAgent,
        index = 0,
        self = this;

    wrapper = function (time) {
        time = performance.now();
        self.callback(time);
    };

    /*!
     bug!
     below code:
     when invoke b after 1s, will only invoke b, not invoke a!

     function a(time){
     console.log("a", time);
     webkitRequestAnimationFrame(a);
     }

     function b(time){
     console.log("b", time);
     webkitRequestAnimationFrame(b);
     }

     a();

     setTimeout(b, 1000);


     so use requestAnimationFrame priority!
     */
    if(window.requestAnimationFrame) {
        return requestAnimationFrame;
    }


    // Workaround for Chrome 10 bug where Chrome
    // does not pass the time to the animation function

    if (window.webkitRequestAnimationFrame) {
        // Define the wrapper

        // Make the switch

        originalRequestAnimationFrame = window.webkitRequestAnimationFrame;

        window.webkitRequestAnimationFrame = function (callback, element) {
            self.callback = callback;

            // Browser calls the wrapper and wrapper calls the callback

            return originalRequestAnimationFrame(wrapper, element);
        }
    }

    //修改time参数
    if (window.msRequestAnimationFrame) {
        originalRequestAnimationFrame = window.msRequestAnimationFrame;

        window.msRequestAnimationFrame = function (callback) {
            self.callback = callback;

            return originalRequestAnimationFrame(wrapper);
        }
    }

    // Workaround for Gecko 2.0, which has a bug in
    // mozRequestAnimationFrame() that restricts animations
    // to 30-40 fps.

    if (window.mozRequestAnimationFrame) {
        // Check the Gecko version. Gecko is used by browsers
        // other than Firefox. Gecko 2.0 corresponds to
        // Firefox 4.0.

        index = userAgent.indexOf('rv:');

        if (userAgent.indexOf('Gecko') != -1) {
            geckoVersion = userAgent.substr(index + 3, 3);

            if (geckoVersion === '2.0') {
                // Forces the return statement to fall through
                // to the setTimeout() function.

                window.mozRequestAnimationFrame = undefined;
            }
        }
    }

    return window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||

        function (callback, element) {
            var start,
                finish;

            window.setTimeout(function () {
                start = performance.now();
                callback(start);
                finish = performance.now();

                self.timeout = 1000 / 60 - (finish - start);

            }, self.timeout);
        };
})();


    window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame
        || window.webkitCancelAnimationFrame
        || window.webkitCancelRequestAnimationFrame
        || window.mozCancelRequestAnimationFrame
        || window.oCancelRequestAnimationFrame
        || window.msCancelRequestAnimationFrame
        || clearTimeout;
```



## HTTP的请求报文结构

### 请求报文

<img src="images/image-20210901165209368.png" alt="image-20210901165209368" style="zoom:67%;" />

```
请求行	请求方法， 请求url（不包括域名）， HTTP协议版本
		get/post			/user							HTTP/1.1
请求头
	user-agent
空行
请求体
```

```
POST /user HTTP/1.1      //请求行
Host: www.user.com
Content-Type: application/x-www-form-urlencoded
Connection: Keep-Alive
User-agent: Mozilla/5.0.      //以上是首部行
（此处必须有一空行）  //空行分割header和请求内容 
name=world   请求体
```

#### HTTP1.1版本

```
		HTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

　　HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。
```

```
User-Agent : 产生请求的浏览器类型
Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型
Content-Type：发送端发送的实体数据的数据类型。
比如，Content-Type：text/html（application/json）表示发送的是html类型。
Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
```

```
请求体：
与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。
```

### 响应报文

```
响应行
响应头
空行
响应体
```

响应行

```
http协议版本	状态码	状态码的文本描述
```

响应头

```
date， content-length， content-type
```

空行

响应体

```
就是返回的内容
```



## TCP三次握手、四次挥手

**TCP报文格式**

![image-20210901172821975](images/image-20210901172821975.png)

```
URG:Urget pointer is valid (紧急指针字段值有效)
SYN: 表示建立连接
FIN: 表示关闭连接
ACK: 表示响应
PSH: 表示有 DATA数据传输
RST: 表示连接重置。
seq：序号
ack：确认序号
ACK：确认标识号
```



### 三次握手

![image-20210901172513186](images/image-20210901172513186.png)

```
seq：序号
ack：确认序号
ACK：确认标识号
```

```
A：发送同步请求，syn：1，随机生成32位的序列号seq，并进入syn.sent状态
B：接收到同步请求后，返回syn：1，ACK：1 确认序号ack，为上一个的序列号+1，同时也自身生成一个随机序列号seq，并进入syn.received
A: 收到B的请求， ack： seq+1， ACk：1，并进入established
B：收到A的请求后，也进入了established，表明了连接建立成功
```

### 四次挥手

![image-20210901173456445](images/image-20210901173456445.png)

```
A：发送FIN，seq=x，变为fin-wait-1状态
B: 接收到了后，发送ack确认序号，ACK，seq，并进入close-wait状态，并会通知应用进程，此时因为服务器可能还有数据处理，
A: 收到B的确认后，进入fin-wait-2状态，
B：数据处理完毕，发送ACK，ack确认序号，seq和FIN，并将状态置为last-ack
A: A收到了b的结束确认，返回ack，ACK，seq，并进入了time-wait状态，等待了2MSL，就关闭
B: 收到了A的结束确认，就关闭了
```

```
MSL：报文最大来回传输时间，Maximum Segment Lifetime，中文可以译为“报文最大生存时间”
```



## HTTP TCP 属于哪个层

网络体系结构分了五层：应用层， 传输层， 网络层， 数据链路层， 物理层。

HTTP属于应用层，TCP属于传输层



## ES6的新特性

### 变量声明 const/let

```
let 关键词声明的变量不具备变量提升（hoisting）特性
let 和 const 声明只在最靠近的一个块中（花括号内）有效
当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING
const 在声明时必须被赋值
```

### 模板字符串

```
es5:
	var str = '';
	
es6:
	let str = ``;
	
基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定；
ES6反引号(``)直接搞定；
```

### 箭头函数（Arrow Functions）

```
不需要 function 关键字来创建函数
省略 return 关键字
继承当前上下文的 this 关键字

function(res => res+1)
```

### 函数的参数默认值

```
// ES6之前，当未传入参数时，text = 'default'；
function printText(text) {
    text = text || 'default';
    console.log(text);
}

// ES6；
function printText(text = 'default') {
    console.log(text);
}
```

### Spread/Rest操作符

```
Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。
```

```
当被用于迭代器中时，它是一个 Spread 操作符：

function foo(x,y,z) {
  console.log(x,y,z);
}
 
let arr = [1,2,3];
foo(...arr); // 1 2 3


当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：

function foo(...args) {
  console.log(args);
}
foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
```

### 二进制和八进制字面量

ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者0O 即可将其转换为八进制值：

```
let oValue = 0o10;
console.log(oValue); // 8
 
let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`
console.log(bValue); // 2
```

### 对象和数组解构

```
// 对象
const student = {
    name: 'Sam',
    age: 22,
    sex: '男'
}
// 数组
// const student = ['Sam', 22, '男'];

// ES5；
const name = student.name;
const age = student.age;
const sex = student.sex;
console.log(name + ' --- ' + age + ' --- ' + sex);

// ES6
const { name, age, sex } = student;
console.log(name + ' --- ' + age + ' --- ' + sex);
```

### 对象超类

ES6 允许在对象中使用 super 方法：

```
var parent = {
  foo() {
    console.log("Hello from the Parent");
  }
}
 
var child = {
  foo() {
    super.foo();
    console.log("Hello from the Child");
  }
}
 
Object.setPrototypeOf(child, parent);
child.foo(); // Hello from the Parent
             // Hello from the Child
```

### for...of 和 for...in

for...of 用于遍历一个迭代器，如数组：

for...in 用来遍历对象中的属性：

### ES6中的类

ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。

函数中使用 static 关键词定义构造函数的的方法和属性：

```
class Student {
  constructor() {
    console.log("I'm a student.");
  }
 
  study() {
    console.log('study!');
  }
 
  static read() {
    console.log("Reading Now.");
  }
}
 
console.log(typeof Student); // function
let stu = new Student(); // "I'm a student."
stu.study(); // "study!"
stu.read(); // "Reading Now."
```

类中的继承和超集：

```
class Phone {
  constructor() {
    console.log("I'm a phone.");
  }
}
 
class MI extends Phone {
  constructor() {
    super();
    console.log("I'm a phone designed by xiaomi");
  }
}
 
let mi8 = new MI();
```

```
extends 允许一个子类继承父类，需要注意的是，子类的constructor 函数中需要执行 super() 函数。
当然，你也可以在子类方法中调用父类的方法，如super.parentMethodName()。
在 这里 阅读更多关于类的介绍。
```

```
有几点值得注意的是：
		类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误
		在类中定义函数不需要使用 function 关键词
```

## 箭头函数和匿名函数的区别

### 匿名函数

```
个人认为，匿名函数常用于几个地方，
回调函数， 将函数赋值给变量， 自调用函数，
所以匿名函数和普通函数应该是没有什么大区别的
```

### 箭头函数

```
为es6的新函数，
特点，简化了函数的定义
```

### 区别

```
this的指向，匿名函数的this指向为调用它的
而箭头函数的this是由词法作用域，由上下文决定
```

```
和带名函数相比，匿名函数需要讲地址赋值给另一个变量let a，然后再用a来调用函数；和匿名函数比，箭头函数完全修复了this的指向，this总是指向词法作用域。
```

## 闭包的定义以及解决的问题，会存在哪些问题

### 什么是闭包

由于在JS中，变量的作用域属于**函数作用域**，在函数**执行后作用域就会被清理、内存也随之被收回**，但是由于**闭包是建立在一个函数内部的子函数**，由于其**可访问上级作用域**的原因，**即使上级函数执行完，作用域也不会随之销毁**，这时的**子函数—也就是闭包**，便拥有了**访问上级作用域中的变量的权限**，即使上级函数执行完后，作**用域内的值也不会被销毁。**

### 解决了什么

阮一峰在他的博客中写到：`在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。`

```
由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。
以平时使用的 AJAX 成功回调为例，这里其实就是个闭包，由于上述的特性，
回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。
开发者不用去学钩子函数来操作上级函数作用域内部的变量了
```

`闭包最大的用处`

 1） 一个是可以读取函数内部的变量；
		 2） 另一个就是让这些变量的值始终保存在内存中。

应用场景：

回调函数（Ajax， 事件绑定），简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时，都有闭包的身影

**特性：**

1. 函数内部嵌套函数
2. 函数内部可以引用外部的变量
3. 参数和变量不会被垃圾回收机制回收

### 存在的问题：

**代码维护**，特别是异步加上了闭包

**内存消耗大**：性能问题。**解决办法**：在退出函数之前，将不使用的局部变量全部删除。

**this指向**：指向的是window

### 闭包是不回收引用的那个对象还是不回收外部整个作用域，你是怎么验证这一点的

```
https://www.iteye.com/blog/justjavac-1465169
```

对于不同的浏览器的js引擎可能会有不同，这个取决于gc，垃圾回收机制，我当时是使用的谷歌的v8引擎验证，发现对于不使用的会被回收，至于验证的方法，我是在浏览器里面通过断点调试，查看变量是否存在来判断的，当然还可以对代码执行以后强制进行一次垃圾回收，来查看内存的变化来判断回收的是对象还是整个作用域。

## 跨域怎么解决

```
https://segmentfault.com/a/1190000011145364
```

### jsonp

简单来说，就是我们请求script标签不会出现跨域问题，所以我们可以把请求放在script标签的src文件上，这样就能进行请求了，缺点，只能进行get请求


    <script>
        var script = document.createElement('script');
        script.type = 'text/javascript';
      // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
      script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
      document.head.appendChild(script);
    
      // 回调执行函数
      function handleCallback(res) {
          alert(JSON.stringify(res));
      }
    </script>
###  document.domain + iframe跨域

此方案仅限主域相同，子域不同的跨域应用场景。

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

### location.hash + iframe

实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

### window.name + iframe跨域

window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

### postMessage跨域

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
	a.） 页面和其打开的新窗口的数据传递
	b.） 多窗口之间消息传递
	c.） 页面与嵌套的iframe消息传递
	d.） 上面三个场景的跨域数据传递

用法：postMessage(data,origin)方法接受两个参数
	data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
	origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

### 跨域资源共享（CORS）

普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。

需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。

目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。

```
// 前端设置是否带cookie
xhr.withCredentials = true;

后端
/*
 * 导入包：import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：HttpServletResponse response
 */

// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'
response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); 

// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示
response.setHeader("Access-Control-Allow-Credentials", "true"); 

// 提示OPTIONS预检时，后端需要设置的两个常用自定义头
response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With");
```

### nginx代理跨域

##### **1、 nginx配置解决iconfont跨域**

浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。

```
location / {
  add_header Access-Control-Allow-Origin *;
}
```

##### **2、 nginx反向代理接口跨域**

跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

### nodejs中间件代理跨域

node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。

### WebSocket协议跨域

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

```
<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });

    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});

document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

## webpack 一般用来做什么，以及怎么去优化

```
https://blog.csdn.net/weixin_43827779/article/details/104457234
https://blog.csdn.net/VhWfR2u02Q/article/details/100149580
```

### **Webpack是用来干什么的**

主要是用来打包、编译的

### **减少 Webpack 打包时间**

**1.优化 Loader**
对于 Loader 来说，影响打包效率首当其冲必属 **Babel** 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。

首先我们可以优化 Loader 的文件搜索范围

对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。

当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间

**2.HappyPack**

开启多线程

受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。

HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了

**3. DllPlugin	/	 Externals	抽离 ** 

DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。

代码压缩
在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。

### **减少 Webpack 打包后的文件体积**

**按需加载**

Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。

Tree Shaking 可以实现删除项目中未被引用的代码。如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能

## 浏览器安全

url，sql注入

输入输入编码

上传文件白名单

## 常用状态码

```
https://www.jianshu.com/p/369db1ba04ea
https://blog.csdn.net/qq_35689573/article/details/82120851
```

**100**：这个状态码是告诉客户端应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应继续发送求请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果



**200**：这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果

**202**：表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定

**204**：服务器成功处理了请求，但没有返回任何实体内容 ，可能会返回新的头部元信息

**206 Partial Content**：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。



**301**：客户端请求的网页已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果，永久重定向

**302 Found**：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。

**303 See Other**：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。

当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。

**304 Not Modified**：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.。

**307 Temporary Redirect**：临时重定向。与302有相同的含义。



**400 Bad Request**：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。

**401 Unauthorized**：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。

**403 Forbidden**：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）

**404 Not Found**：服务器上没有请求的资源。路径错误等。



**500 Internal Server Error：**貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。

**503 Service Unavailable**：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。

## 返回304状态码的流程，属于哪一种缓存机制

首先就是文件要有 Etag 和 last-modified，当浏览器请求这个资源的时候，发现了本地所对应的这个资源存在etag和last-modified，就会把这两个写入请求头，etag => if-none-match  last-modified => if-modified-since ，然后服务器就会查看做对应的值是否相等，如果相等，那么就会直接返回304，并在response headers里面添加 etag 和 last-modified，此时，浏览器接收到响应之后，就会从本地进行加载

### **交互流程**

客户端第一次请求服务端的某个地址时，服务端会在响应时**携带 ETag 与 Last-Modified 响应头**，客户端下次再发送同一地址的请求时，**会携带 If-None-Match 与 If-Modified-Since 请求头**，而 **If-None-Match 就是 ETag 的值，If-Modified-Since 就是 Last-Modified 的值**，这时服务端在接收请求后会获取请求头中的这两个值，然后进行比对，**若资源没有更新，则响应 304 状态码**，表示请求的资源没有更新，客户端可以从自己的缓存里获取，**若资源已更新，则响应 200 状态码**，同第一次请求一样，又会在响应时**携带新的 ETag 与 Last-Modified 响应头，之后同上逻辑循环。**

### ETag 与 If-None-Match

**ETag** 是属于 HTTP 1.1 属性，它是由服务器生成返回给前端，说白了，ETag 一般为资源的哈希值，即 ETag 就是服务器生成的一个标记，用来标识资源是否有变化的，**且 ETag 的优先级高于 Last-Modified。**

**Last-Modified 与 If-Modified-Since**

Last-Modified 与 ETag 类似。不过 Last-Modified 表示响应资源在服务器最后修改时间而已。

**与 ETag 相比，不足为：**

​	**Last-Modified 标注的最后修改只能精确到秒级，**如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；

​	**如果某些文件会被定期生成，但有时内容并没有任何变化，**而 Last-Modified 却改变了，导致文件没法使用缓存；

​	**有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致**等情形；

然而，**ETag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。**

### 缓存机制

协商缓存

## 浏览器的缓存机制

```
https://zhuanlan.zhihu.com/p/25953524
https://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html
```

**1.强缓存**：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；

**2.协商缓存**：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

**两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。**

### 缓存有关的header

#### 强缓存

Expires：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。
Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

![img](images/v2-a5fa149922f1fc8959796cb4ab58db12_720w.png)

> Expires和Cache-Control:max-age=*** 的作用是差不多的，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法

（编辑补充：Expires和Cache-Control的区别还有一个：Expires是一个具体的服务器时间，这就导致一个问题，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control是一个时间段，控制就比较容易。）

#### 协商缓存

ETag和If-None-Match：这两个要一起说。Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。

![img](images/v2-9ef478c7b3eafd3c94cf943a9b0fd124_720w.png)



Last-Modified和If-Modified-Since：这两个也要一起说。Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。

![img](images/v2-183e852bbc3c1c26062b22164019e7a1_720w.png)

> ETag和Last-Modified的作用和用法也是差不多，说一说他们的区别。
> 首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。
>
> 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
> 第三在优先级上，服务器校验优先考虑Etag。

### 缓存过程

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；
3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

### 用户行为对浏览器缓存的控制

1. 地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；
2. F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；
3. ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。

## CDN原理

```
https://blog.csdn.net/qq_40563761/article/details/100975035
https://blog.csdn.net/xiangzhihong8/article/details/83147542
```

### 概述

CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的**CACHE(缓存)层**，将网站的内容发布到最接近用户的网络”**边缘**“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。

### 传统未加缓存的服务访问过程

<img src="images/image-20210904215649861.png" alt="image-20210904215649861" style="zoom:67%;" />

**流程如下：**

用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址；

LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)；

ROOT DNS将域名授权dns记录回应给 LocalDns；

LocalDns得到域名的授权dns记录后，继续向域名授权dns查询域名的ip地址；

域名授权dns 查询域名记录后，回应给 LocalDns；

LocalDns 将得到的域名ip地址，回应给用户端；

用户得到域名ip地址后，访问站点服务器；

站点服务器应答请求，将内容返回给客户端.

### **加了cdn缓存后的流程**

<img src="images/image-20210904215753980.png" alt="image-20210904215753980" style="zoom:67%;" />

**流程**：

用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址；

LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)；

ROOT DNS将域名授权dns记录回应给 LocalDns；

LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址；

域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDns；

LocalDns 得到域名记录后,向智能调度DNS查询域名的ip地址；

智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns；

LocalDns 将得到的域名ip地址，回应给用户端；

用户得到域名ip地址后，访问站点服务器。

















# 算法

## 螺旋矩阵

```

```







# end