# 面试

## 回流/重绘

```

```



## 避免回流

```

```





## requestAnimationFrame 为什么不会掉帧

```
	首先，我们可以知道布局绘制和js执行都是在主线程进行的执行的，
	所以，如果当js拿到主线程执行权后，有可能会出现执行时间过长，导致在下一帧的开始js没有及时归还主线程，导致下一帧没有按时渲染，于是就会出现掉帧，而这个requestAnimationFrame方法就是解决这个问题的，
	他会在每一帧被调用，通过回调函数，会把js任务分成更小的任务快，并且会在每一帧时间用完暂停js的执行，归还主线程，所以布局绘制就会在每帧及时拿到主线程的使用权，所以不会掉帧。
```

```
requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。
「requestAnimationFrame的步伐跟着系统的刷新步伐走」，
「它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次」，
「这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题」。
```

```
requestAnimationFrame还有以下两个优势：

「CPU节能」：
		使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。

「函数节流」：
		在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。
```

下面为《HTML5 Canvas 核心技术》给出的兼容主流浏览器的requestNextAnimationFrame 和cancelNextRequestAnimationFrame方法

```
window.requestNextAnimationFrame = (function () {
    var originalRequestAnimationFrame = undefined,
        wrapper = undefined,
        callback = undefined,
        geckoVersion = null,
        userAgent = navigator.userAgent,
        index = 0,
        self = this;

    wrapper = function (time) {
        time = performance.now();
        self.callback(time);
    };

    /*!
     bug!
     below code:
     when invoke b after 1s, will only invoke b, not invoke a!

     function a(time){
     console.log("a", time);
     webkitRequestAnimationFrame(a);
     }

     function b(time){
     console.log("b", time);
     webkitRequestAnimationFrame(b);
     }

     a();

     setTimeout(b, 1000);


     so use requestAnimationFrame priority!
     */
    if(window.requestAnimationFrame) {
        return requestAnimationFrame;
    }


    // Workaround for Chrome 10 bug where Chrome
    // does not pass the time to the animation function

    if (window.webkitRequestAnimationFrame) {
        // Define the wrapper

        // Make the switch

        originalRequestAnimationFrame = window.webkitRequestAnimationFrame;

        window.webkitRequestAnimationFrame = function (callback, element) {
            self.callback = callback;

            // Browser calls the wrapper and wrapper calls the callback

            return originalRequestAnimationFrame(wrapper, element);
        }
    }

    //修改time参数
    if (window.msRequestAnimationFrame) {
        originalRequestAnimationFrame = window.msRequestAnimationFrame;

        window.msRequestAnimationFrame = function (callback) {
            self.callback = callback;

            return originalRequestAnimationFrame(wrapper);
        }
    }

    // Workaround for Gecko 2.0, which has a bug in
    // mozRequestAnimationFrame() that restricts animations
    // to 30-40 fps.

    if (window.mozRequestAnimationFrame) {
        // Check the Gecko version. Gecko is used by browsers
        // other than Firefox. Gecko 2.0 corresponds to
        // Firefox 4.0.

        index = userAgent.indexOf('rv:');

        if (userAgent.indexOf('Gecko') != -1) {
            geckoVersion = userAgent.substr(index + 3, 3);

            if (geckoVersion === '2.0') {
                // Forces the return statement to fall through
                // to the setTimeout() function.

                window.mozRequestAnimationFrame = undefined;
            }
        }
    }

    return window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||

        function (callback, element) {
            var start,
                finish;

            window.setTimeout(function () {
                start = performance.now();
                callback(start);
                finish = performance.now();

                self.timeout = 1000 / 60 - (finish - start);

            }, self.timeout);
        };
})();


    window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame
        || window.webkitCancelAnimationFrame
        || window.webkitCancelRequestAnimationFrame
        || window.mozCancelRequestAnimationFrame
        || window.oCancelRequestAnimationFrame
        || window.msCancelRequestAnimationFrame
        || clearTimeout;
```



## HTTP的请求报文结构

```
请求行	请求方法， 请求url（不包括域名）， HTTP协议版本
		get/post			/user							HTTP/1.1
请求头
	user-agent
空行
请求体
```

```
POST /user HTTP/1.1      //请求行
Host: www.user.com
Content-Type: application/x-www-form-urlencoded
Connection: Keep-Alive
User-agent: Mozilla/5.0.      //以上是首部行
（此处必须有一空行）  //空行分割header和请求内容 
name=world   请求体
```

### HTTP1.1版本

```
		HTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

　　HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。
```

```
User-Agent : 产生请求的浏览器类型
Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型
Content-Type：发送端发送的实体数据的数据类型。
比如，Content-Type：text/html（application/json）表示发送的是html类型。
Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
```





- TCP三次握手、四次挥手
- HTTP TCP 属于哪个层
- ES6的新特性
- 箭头函数和匿名函数的区别
- 闭包的定义以及解决的问题，会存在哪些问题
- 闭包是不回收引用的那个对象还是不回收外部整个作用域，你是怎么验证这一点的
- 跨域怎么解决
- webpack 一般用来做什么，以及怎么去优化
- 浏览器安全
- 常用状态码
- 返回304状态码的流程，属于哪一种缓存机制
- 浏览器的缓存机制
- [项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)中怎么设置强制缓存
- 你觉得框架的性能会赶上原生嘛
- 三年之内的[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)规划，你会怎么去实现你的这个规划



- 面试官是个好人，很和蔼，继去年[春招](https://www.nowcoder.com/jump/super-jump/word?word=春招)阿里面试后的第一次体验非常好的一次面试
- 简单介绍一下做过的[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)
- 如果你负责一个[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)的话，你会怎么做技术选型
- 一个场景，经理说页面加载慢，你会怎么去定位问题并解决
- CDN原理
- 你认为一个JS脚本多大才是合适的
- 浏览器的缓存机制
- 最近看的技术博客，或者最近了解到的新技术
- 你认为最近了解到的技术有哪些难点
- 你认为看了React[源码](https://www.nowcoder.com/jump/super-jump/word?word=源码)之后你学到了什么
- 一道[算法题](https://www.nowcoder.com/jump/super-jump/word?word=算法题)，[螺旋矩阵](https://www.nowcoder.com/jump/super-jump/word?word=螺旋矩阵)
- 三到五年内的规划





# end