# 面试

## 回流/重绘

```
https://blog.csdn.net/weixin_34353714/article/details/91445129
```

### 浏览器的渲染过程

```
https://blog.csdn.net/farsight1/article/details/79758347
处理 HTML 并tokeniser标记构造 DOM 树。
处理 CSS 标记并构造 CSSOM 树。
如果遇到了js会停止dom树的解析，并且如果js还操作了cssom，并且cssom没有下载和构建，浏览器甚至会延迟脚本执行和构建dom，直至cssom的下载完成和构建
然后 将dom和cssom合并位渲染树 render tree
根据渲染树来布局，计算每个节点的几何信息
将节点绘制到屏幕上
```

### 渲染树 的生成

```
遍历可见的节点
对于可见的节点，找到cssom的规则，并 渲染

注意：
一些不会渲染输出的节点。比如 script、meta、link等。是不可见的
某些节点通过 CSS 隐藏。注意 visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。
```

### 回流(reflow)

当 Render Tree 中**部分或全部, 因元素的尺寸、布局、隐藏等改变而需要重新构建，浏览器重新渲染的过程**称为回流。

```
会导致回流的操作：
  页面首次渲染。
  浏览器窗口大小发生改变。
  元素尺寸或者位置发生改变。
  元素内容变化(文字数量或者图片大小发生改变)。
  元素字体大小的改变。
  添加或者删除可见的 DOM 元素。
  激活 CSS 伪类 (eg: :hover)。
  查询某些属性或调用某些方法。

一些常用且会导致回流的属性和方法。
  clientWidth、clientHeight、clientTop、clientLeft
  offsetWidth、offsetHeight、offsetTop、offsetLeft
  scrollWidth、scrollHeight、scrollTop、scrollLeft
  scrollIntoView()、scrollIntoViewIfNeeded()
  getComputedStyle()
  getBoundingClientRect()
  scrollTo()
```

### 重绘(repaint)

当页面中元素样式的改变并不影响布局时（eg：`color`、`background-color`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**一句话： 回流必将引起重绘，重绘不一定会引起回流。**

### 现代浏览器对频繁的回流/重绘的优化

浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

```
当你访问以下属性或方法时，浏览器会立刻清空队列：
  clientWidth、clientHeight、clientTop、clientLeft
  offsetWidth、offsetHeight、offsetTop、offsetLeft
  scrollWidth、scrollHeight、scrollTop、scrollLeft
  scrollIntoView()、scrollIntoViewIfNeeded()
  getComputedStyle()
  getBoundingClientRect()
  scrollTo()
 
		因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。
```

### 优化回流

```
减少 render tree 操作，合并多次多dom和样式的的修改
减少对一些style信息的请求，尽量利用好浏览器的优化策略
```

#### css

直接改变className

避免使用table布局(尽量不要使用表格布局，如果没有定宽表格一列的宽度由最宽的一列决定，那么很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。)

尽可能在dom树的最末端改变class，尽可能在dom树的里面改变class（可以显示回流的范围）

将需要多次重排的元素，position属性设置位absolute或fixed，这样此元素就脱离了文档流，她的变化不会影响到其他元素。例如有动画效果的元素就最好 设置为绝对定位。

使用 display:none技术，只引发两次回流和重绘。

#### js

避免频繁操作，最好一次性重写style属性，或者将样式列表定义为class，并一次性更改class属性，而不是利用js控制样式

不要经常访问会引起浏览器缓存队列的属性（上述那些浏览器会立刻清空队列的属性）。如果确实要访问，利用缓存 eg：

```
// bad
for (var i = 0; i < len; i++) {
  el.style.left = el.offsetLeft + x + "px";
  el.style.top = el.offsetTop + y + "px";
}

// good
var x = el.offsetLeft,
    y = el.offsetTop;
for (var i = 0; i < len; i++) {
  x += 10;
  y += 10;
  el.style = x + "px";
  el.style = y + "px";
}
```

尽量将需要改变dom的操作一次完成

```
let box = document.getElementById("box").style;
// bad
box.color = "red";    // 重绘
box.size = "14px";    // 回流、重绘

// good
box.bord = '1px solid red'
```

对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

避免频繁操作 `DOM`，创建一个`documentFragment`，在它上面应用所有 `DOM` 操作，最后再把它添加到文档中。

```
DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象. 与 Document 最大的区别是因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的（重新渲染) ，且不会导致性能等问题。

可以使用 document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.
```

## requestAnimationFrame 为什么不会掉帧

```
	首先，我们可以知道布局绘制和js执行都是在主线程进行的执行的，
	所以，如果当js拿到主线程执行权后，有可能会出现执行时间过长，导致在下一帧的开始js没有及时归还主线程，导致下一帧没有按时渲染，于是就会出现掉帧，而这个requestAnimationFrame方法就是解决这个问题的，
	他会在每一帧被调用，通过回调函数，会把js任务分成更小的任务快，并且会在每一帧时间用完暂停js的执行，归还主线程，所以布局绘制就会在每帧及时拿到主线程的使用权，所以不会掉帧。
```

```
requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。
「requestAnimationFrame的步伐跟着系统的刷新步伐走」，
「它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次」，
「这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题」。
```

```
requestAnimationFrame还有以下两个优势：

「CPU节能」：
		使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。

「函数节流」：
		在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。
```

下面为《HTML5 Canvas 核心技术》给出的兼容主流浏览器的requestNextAnimationFrame 和cancelNextRequestAnimationFrame方法

```
window.requestNextAnimationFrame = (function () {
    var originalRequestAnimationFrame = undefined,
        wrapper = undefined,
        callback = undefined,
        geckoVersion = null,
        userAgent = navigator.userAgent,
        index = 0,
        self = this;

    wrapper = function (time) {
        time = performance.now();
        self.callback(time);
    };

    /*!
     bug!
     below code:
     when invoke b after 1s, will only invoke b, not invoke a!

     function a(time){
     console.log("a", time);
     webkitRequestAnimationFrame(a);
     }

     function b(time){
     console.log("b", time);
     webkitRequestAnimationFrame(b);
     }

     a();

     setTimeout(b, 1000);


     so use requestAnimationFrame priority!
     */
    if(window.requestAnimationFrame) {
        return requestAnimationFrame;
    }


    // Workaround for Chrome 10 bug where Chrome
    // does not pass the time to the animation function

    if (window.webkitRequestAnimationFrame) {
        // Define the wrapper

        // Make the switch

        originalRequestAnimationFrame = window.webkitRequestAnimationFrame;

        window.webkitRequestAnimationFrame = function (callback, element) {
            self.callback = callback;

            // Browser calls the wrapper and wrapper calls the callback

            return originalRequestAnimationFrame(wrapper, element);
        }
    }

    //修改time参数
    if (window.msRequestAnimationFrame) {
        originalRequestAnimationFrame = window.msRequestAnimationFrame;

        window.msRequestAnimationFrame = function (callback) {
            self.callback = callback;

            return originalRequestAnimationFrame(wrapper);
        }
    }

    // Workaround for Gecko 2.0, which has a bug in
    // mozRequestAnimationFrame() that restricts animations
    // to 30-40 fps.

    if (window.mozRequestAnimationFrame) {
        // Check the Gecko version. Gecko is used by browsers
        // other than Firefox. Gecko 2.0 corresponds to
        // Firefox 4.0.

        index = userAgent.indexOf('rv:');

        if (userAgent.indexOf('Gecko') != -1) {
            geckoVersion = userAgent.substr(index + 3, 3);

            if (geckoVersion === '2.0') {
                // Forces the return statement to fall through
                // to the setTimeout() function.

                window.mozRequestAnimationFrame = undefined;
            }
        }
    }

    return window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||

        function (callback, element) {
            var start,
                finish;

            window.setTimeout(function () {
                start = performance.now();
                callback(start);
                finish = performance.now();

                self.timeout = 1000 / 60 - (finish - start);

            }, self.timeout);
        };
})();


    window.cancelNextRequestAnimationFrame = window.cancelRequestAnimationFrame
        || window.webkitCancelAnimationFrame
        || window.webkitCancelRequestAnimationFrame
        || window.mozCancelRequestAnimationFrame
        || window.oCancelRequestAnimationFrame
        || window.msCancelRequestAnimationFrame
        || clearTimeout;
```



## HTTP的请求报文结构

### 请求报文

<img src="images/image-20210901165209368.png" alt="image-20210901165209368" style="zoom:67%;" />

```
请求行	请求方法， 请求url（不包括域名）， HTTP协议版本
		get/post			/user							HTTP/1.1
请求头
	user-agent
空行
请求体
```

```
POST /user HTTP/1.1      //请求行
Host: www.user.com
Content-Type: application/x-www-form-urlencoded
Connection: Keep-Alive
User-agent: Mozilla/5.0.      //以上是首部行
（此处必须有一空行）  //空行分割header和请求内容 
name=world   请求体
```

#### HTTP1.1版本

```
		HTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

　　HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。
```

```
User-Agent : 产生请求的浏览器类型
Accept : 客户端希望接受的数据类型，比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型
Content-Type：发送端发送的实体数据的数据类型。
比如，Content-Type：text/html（application/json）表示发送的是html类型。
Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
```

```
请求体：
与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。
```

### 响应报文

```
响应行
响应头
空行
响应体
```

响应行

```
http协议版本	状态码	状态码的文本描述
```

响应头

```
date， content-length， content-type
```

空行

响应体

```
就是返回的内容
```



## TCP三次握手、四次挥手

**TCP报文格式**

![image-20210901172821975](images/image-20210901172821975.png)

```
URG:Urget pointer is valid (紧急指针字段值有效)
SYN: 表示建立连接
FIN: 表示关闭连接
ACK: 表示响应
PSH: 表示有 DATA数据传输
RST: 表示连接重置。
```



### 三次握手

![image-20210901172513186](images/image-20210901172513186.png)

```
seq：序号
ack：确认序号
ACK：确认标识号
```

```
A：发送同步请求，syn：1，随机生成32位的序列号seq，并进入syn.sent状态
B：接收到同步请求后，返回syn：1，ACK：1 确认序号ack，为上一个的序列号+1，同时也自身生成一个随机序列号seq，并进入syn.received
A: 收到B的请求， ack： seq+1， ACk：1，并进入established
B：收到A的请求后，也进入了established，表明了连接建立成功
```

### 四次挥手

![image-20210901173456445](images/image-20210901173456445.png)

```
A：发送FIN，seq=x，变为fin-wait-1状态
B: 接收到了后，发送ack确认序号，ACK，seq，并进入close-wait状态，并会通知应用进程，此时因为服务器可能还有数据处理，
A: 收到B的确认后，进入fin-wait-2状态，
B：数据处理完毕，发送ACK，ack确认序号，seq和FIN，并将状态置为last-ack
A: A收到了b的结束确认，返回ack，ACK，seq，并进入了time-wait状态，等待了2MSL，就关闭
B: 收到了A的结束确认，就关闭了
```

```
MSL：报文最大来回传输时间，Maximum Segment Lifetime，中文可以译为“报文最大生存时间”
```



## HTTP TCP 属于哪个层

网络体系结构分了五层：应用层， 传输层， 网络层， 数据链路层， 物理层。

HTTP属于应用层，TCP属于传输层



## ES6的新特性

### 变量声明 const/let

```
let 关键词声明的变量不具备变量提升（hoisting）特性
let 和 const 声明只在最靠近的一个块中（花括号内）有效
当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING
const 在声明时必须被赋值
```

### 模板字符串

```
es5:
	var str = '';
	
es6:
	let str = ``;
	
基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定；
ES6反引号(``)直接搞定；
```

### 箭头函数（Arrow Functions）

```
不需要 function 关键字来创建函数
省略 return 关键字
继承当前上下文的 this 关键字

function(res => res+1)
```

### 函数的参数默认值

```
// ES6之前，当未传入参数时，text = 'default'；
function printText(text) {
    text = text || 'default';
    console.log(text);
}

// ES6；
function printText(text = 'default') {
    console.log(text);
}
```

### Spread/Rest操作符

```
Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。
```

```
当被用于迭代器中时，它是一个 Spread 操作符：

function foo(x,y,z) {
  console.log(x,y,z);
}
 
let arr = [1,2,3];
foo(...arr); // 1 2 3


当被用于函数传参时，是一个 Rest 操作符：当被用于函数传参时，是一个 Rest 操作符：

function foo(...args) {
  console.log(args);
}
foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
```

### 二进制和八进制字面量

ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者0O 即可将其转换为八进制值：

```
let oValue = 0o10;
console.log(oValue); // 8
 
let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`
console.log(bValue); // 2
```

### 对象和数组解构

```
// 对象
const student = {
    name: 'Sam',
    age: 22,
    sex: '男'
}
// 数组
// const student = ['Sam', 22, '男'];

// ES5；
const name = student.name;
const age = student.age;
const sex = student.sex;
console.log(name + ' --- ' + age + ' --- ' + sex);

// ES6
const { name, age, sex } = student;
console.log(name + ' --- ' + age + ' --- ' + sex);
```

### 对象超类

ES6 允许在对象中使用 super 方法：

```
var parent = {
  foo() {
    console.log("Hello from the Parent");
  }
}
 
var child = {
  foo() {
    super.foo();
    console.log("Hello from the Child");
  }
}
 
Object.setPrototypeOf(child, parent);
child.foo(); // Hello from the Parent
             // Hello from the Child
```

### for...of 和 for...in

for...of 用于遍历一个迭代器，如数组：

for...in 用来遍历对象中的属性：

### ES6中的类

ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。

函数中使用 static 关键词定义构造函数的的方法和属性：

```
class Student {
  constructor() {
    console.log("I'm a student.");
  }
 
  study() {
    console.log('study!');
  }
 
  static read() {
    console.log("Reading Now.");
  }
}
 
console.log(typeof Student); // function
let stu = new Student(); // "I'm a student."
stu.study(); // "study!"
stu.read(); // "Reading Now."
```

类中的继承和超集：

```
class Phone {
  constructor() {
    console.log("I'm a phone.");
  }
}
 
class MI extends Phone {
  constructor() {
    super();
    console.log("I'm a phone designed by xiaomi");
  }
}
 
let mi8 = new MI();
```

```
extends 允许一个子类继承父类，需要注意的是，子类的constructor 函数中需要执行 super() 函数。
当然，你也可以在子类方法中调用父类的方法，如super.parentMethodName()。
在 这里 阅读更多关于类的介绍。
```

```
有几点值得注意的是：
		类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误
		在类中定义函数不需要使用 function 关键词
```

## 箭头函数和匿名函数的区别

### 匿名函数

```
个人认为，匿名函数常用于几个地方，
回调函数， 将函数赋值给变量， 自调用函数，
所以匿名函数和普通函数应该是没有什么大区别的
```

### 箭头函数

```
为es6的新函数，
特点，简化了函数的定义
```

### 区别

```
this的指向，匿名函数的this指向为调用它的
而箭头函数的this是由词法作用域，由上下文决定
```

```
和带名函数相比，匿名函数需要讲地址赋值给另一个变量let a，然后再用a来调用函数；和匿名函数比，箭头函数完全修复了this的指向，this总是指向词法作用域。
```





















- 闭包的定义以及解决的问题，会存在哪些问题
- 闭包是不回收引用的那个对象还是不回收外部整个作用域，你是怎么验证这一点的
- 跨域怎么解决
- webpack 一般用来做什么，以及怎么去优化
- 浏览器安全
- 常用状态码
- 返回304状态码的流程，属于哪一种缓存机制
- 浏览器的缓存机制
- [项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)中怎么设置强制缓存
- 你觉得框架的性能会赶上原生嘛
- 三年之内的[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)规划，你会怎么去实现你的这个规划



- 面试官是个好人，很和蔼，继去年[春招](https://www.nowcoder.com/jump/super-jump/word?word=春招)阿里面试后的第一次体验非常好的一次面试
- 简单介绍一下做过的[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)
- 如果你负责一个[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)的话，你会怎么做技术选型
- 一个场景，经理说页面加载慢，你会怎么去定位问题并解决
- CDN原理
- 你认为一个JS脚本多大才是合适的
- 浏览器的缓存机制
- 最近看的技术博客，或者最近了解到的新技术
- 你认为最近了解到的技术有哪些难点
- 你认为看了React[源码](https://www.nowcoder.com/jump/super-jump/word?word=源码)之后你学到了什么
- 一道[算法题](https://www.nowcoder.com/jump/super-jump/word?word=算法题)，[螺旋矩阵](https://www.nowcoder.com/jump/super-jump/word?word=螺旋矩阵)
- 三到五年内的规划





# end